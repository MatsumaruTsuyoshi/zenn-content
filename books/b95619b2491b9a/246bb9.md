---
title: "項目1：コンストラクタの代わりにstaticファクトリメソッドを検討する"
free: false
---

## コンストラクタとstaticファクトリメソッドの違い

#### コンストラクタの場合

```kotlin
class MyObject(val value: Int)

// 呼び出し例
val obj = MyObject(123)
```

#### staticファクトリメソッドの場合
kotlinでは`companion object`という仕組みを使います。

```kotlin:
class MyObject private constructor(val value: Int) {
    companion object {
        fun valueOf(value: Int): MyObject {
            return MyObject(value)
        }
    }
}

// 呼び出し例
val obj = MyObject.valueOf(123)
```
この違いを頭の片隅に入れておくと、これからstaticファクトリメソッドのメリット、デメリットを理解しやすいかなと思います。

また、kotlinでstaticファクトリメソッドを表現する方法はいくつかありますが、それは後ほど紹介します。

## staticファクトリメソッドを検討する理由
こらからstaticファクトリメソッドのメリット、デメリットを解説していきます。

### staticファクトリメソッドのメリット 
1. **わかりやすい名前をつけられる** : 各メソッドに具体的な名前をつけることができるので、その機能が何をするものか理解しやすくなります。 上記の例で言うと、`valueOf`の部分になります。
2. **同じオブジェクトの再利用** : 一度作ったオブジェクトを何度も使いまわすことができるので、メモリを節約し、速度も向上させることができます。 
3. **返り値の型を柔軟に決められる** : 異なる種類のオブジェクトを返すことができるので、プログラムの変更が簡単になります。 ここは後述するstaticファクトリメソッド活用例を見てもらえれば理解しやすいと思います。


### staticファクトリメソッドのデメリット
1. **サブクラスを作れない** : これも後述する参考例を見てください。
2. **発見しづらい** : 見つけづらくなるので、下記命名規約を遵守するようにしましょう。





| 命名規則          | 説明                                                                        | 例                                         |
|-----------------|---------------------------------------------------------------------------|---------------------------------------------------|
| from            | 単一のパラメータを受け取り、このパラメータの型のインスタンスを返します。                           | `LocalDate.from(temporalAccessor)`                 |
| of              | 複数のパラメータを受け取り、これらのパラメータからインスタンスを構築します。                        | `LocalDateTime.of(date, time) `                    |
| valueOf         | fromやofの代わりとなる、冗長な名前のメソッドです。                                      | `Enum.valueOf(enumType, name)`                     |
| get系     |  自身のクラスとは異なるクラスを返却する。    | `Files.getFileStore(path)`          |
| new系     |   自身のクラスとは異なるクラスを返却する。呼び出しごとに新たなインスタンスを返す。   | `Files.newBufferedReader(path)`          |

## Kotlinでstaticファクトリメソッドを実装する手段

4つ紹介します。

### 1. コンパニオンオブジェクトを使用する

Kotlinでは`static`キーワードが存在しないため、クラスレベルの関数やプロパティを定義するにはコンパニオンオブジェクト（`companion object`）を使用します。コンパニオンオブジェクト内で定義されたメソッドは、Javaの`static`メソッドのように動作します。

```kotlin
class MyClass {
    companion object {
        fun create(): MyClass = MyClass()
    }
}
```



この方法では、`MyClass.create()`で新しいインスタンスを生成できます。
### 2. オブジェクト宣言を使用する

独立したオブジェクト宣言でファクトリメソッドを定義することもできます。これは、ファクトリが複数のクラスに対して機能を提供する場合に便利です。

```kotlin
object MyFactory {
    fun create(): MyClass = MyClass()
}
```



この方法では、`MyFactory.create()`を使用してインスタンスを生成します。
### 3. トップレベル関数を使用する

関数がクラスと密接に関連していない場合、トップレベル関数としてファクトリメソッドを定義することができます。これにより、グローバルにアクセス可能な関数を作成できます。

```kotlin
fun createMyClass(): MyClass = MyClass()
```



この関数はパッケージレベルで定義されるため、特定のクラスに属さないことに注意してください。
### 4. 拡張関数を使用する

特定の型に対するファクトリメソッドを定義するには、拡張関数を使用すると良いでしょう。これにより、既存の型に新しいファクトリメソッドを追加できます。

```kotlin
fun MyClass.Companion.create(): MyClass = MyClass()
```



ここでは、`MyClass`のコンパニオンオブジェクトに対する拡張関数としてファクトリメソッドを定義しています。

これらの方法を適切に選択することで、Kotlinにおいて`static`ファクトリメソッドを効果的に実装できます。どの方法を選ぶかは、メソッドがどのように使用されるか、どの範囲で利用可能であるべきかによって決まります。

## staticファクトリメソッド活用例

具体的な例としてCollection Frameworkの`listOf`を見ていきたいと思います。

`listOf`の実装は以下のようになっています。トップレベル関数ですね。
```kotlin:Collections.kt
public fun <T> listOf(vararg elements: T): List<T> = 
    if (elements.size > 0) elements.asList() else emptyList()
```
### メリットについて


1. **わかりやすい名前をつけられる**
`listOf`という名前は、このメソッドがリストを生成することを明確に伝えます。メソッド名からその機能と返り値がリストであることが直感的に理解できるため、コードを読んでいる人にとって何をするメソッドなのかがすぐにわかります。この明瞭さは、コードの可読性とメンテナンス性を向上させます。


2. **同じオブジェクトの再利用**
`listOf`は要素がない場合（elements.sizeが0の場合）、emptyList()を呼び出して空の不変リストを返します。emptyList()はシングルトンインスタンスを返すため、空のリストが必要な場合には常に同じインスタンスが使用され、メモリ効率が良いです。


```kotlin
public fun <T> emptyList(): List<T> = EmptyList
```

EmptyListはobjectなのでアクセスしたときに初期化されます。

```kotlin
internal object EmptyList : List<Nothing>, Serializable, RandomAccess {
    //略
}
```

3. **返り値の型を柔軟に決められる**
`listOf`はジェネリックスを使用しており、任意の型の要素を含むリストを生成できます。これにより、同じメソッドを使用して異なる型のリストを作成することができ、柔軟性が高まります。例えば、`listOf(1, 2, 3)`は整数のリストを、`listOf("a", "b", "c")`は文字列のリストを生成します。返り値の型はメソッドに渡される引数の型に依存し、これにより同一のインターフェイスを通じて多様なリストが簡単に作成できます。

### デメリットについて

1. **サブクラスを作れない** 
`emptyList()`ではEmptyListが返却されますが、EmptyListはprivateなクラスのため、利用者はEmptyListのサブクラスを作れません。

## まとめ
たいていは、staticファクトリメソッドが好ましいので最初にstaticファクトリメソッドを検討するようにしましょう。